#!/usr/bin/env python3
"""
Riddler: Null Set - Solution Script (Hex approach)

Maybe these large numbers should be treated as hex-encoded bytes
"""

# The three "bombs" (ciphertexts) - treating as hex strings
hospital_hex = "17228885174970084276161970522097412605266394159971647740752267300221714788550197385293497867284890619874129427467673441688167088281496263523126626874873040420690149997429144654882986643604004320995801451651978549126665724326037323443693785147308295273804941176324595270160848031743691643352199091770561183390101638892864365971529361775777473322338259828117124021731569968581096105773133290818616623517239075045010723533051858606599891085860123293236498867687161911760308272069433482552999066140765265852927860548903142423166019118304640362315363826033542802010314992302177183041218307694787831493560402247717975058777"
subway_hex = "18599394198408159559032127206556973904470958589652384401139516143215782574096306554190666147629219501568720150220610776907290318953673688570966652188653414334135944107812388490123363711694776438197910528441090458287491320232545060818540405255660036329115175285563075067615115662971223964466609690121087345003072037826745412886843594744373925001833637904010490107159214131436719753440343088809862147325818389229992483097674780613975438662993160352072711897374040436210067117793225426902614028702255450993606803712362745736227617347976687372229897332444483782057154829741076097868855041890160420732593056490770604016963"
financial_hex = "21465018203265794097113095991538507070009934123584712754183836984749947784914875073029917205704709806063598091539183323502642805321030095506965670322592578944062438932372074147246983365306801187413681411691600283518148755726465920648688770335822658763606803297069673119665208343264880669287960265441639527802610566656299685318339460983357111370900461103556978263689008699830462732473301850828945035801211567525902267631084241059888222620103913512778392054697511670625304307246238730039519706049298726456456715325025195145205840264871637036819903723164701441937741275296892662198340153409014099281713703913671372908819"
flag_hex = "2688799573415612194172688341985385655869767021669706325971969222982091539107082257386772222987306933827264001995669863266148641628566567467721627695226828529063310337313730890984773336370189319810197054705752635402192590291140330841505400796372134659065052651929114899378965182328524235056804062656407286061152078766613035623406173201907601732254045680536238007225975731741967059981506881028597601704173481437206652323544395617004541689706710800898777397919180336353911831098500922631432068656317452009839798641849451740369839351859125801709185337650226880544125158905221302154116578507914015625510759196575232097337"

print("=== Trying hex interpretation ===\n")

# Convert these long number strings to bytes by treating them as hex
# But they're decimal numbers, so we need to convert decimal to hex first

hospital_int = int(hospital_hex)
subway_int = int(subway_hex)
financial_int = int(financial_hex)
flag_int = int(flag_hex)

# Convert to actual hex
h_hex = hex(hospital_int)[2:]
s_hex = hex(subway_int)[2:]
f_hex = hex(financial_int)[2:]
flag_hex_actual = hex(flag_int)[2:]

print(f"Hospital as hex: {h_hex[:100]}...")
print(f"Subway as hex: {s_hex[:100]}...")
print(f"Financial as hex: {f_hex[:100]}...")
print(f"Flag as hex: {flag_hex_actual[:100]}...")
print()

# Ensure even length
if len(h_hex) % 2: h_hex = '0' + h_hex
if len(s_hex) % 2: s_hex = '0' + s_hex
if len(f_hex) % 2: f_hex = '0' + f_hex
if len(flag_hex_actual) % 2: flag_hex_actual = '0' + flag_hex_actual

# Convert to bytes
h_bytes = bytes.fromhex(h_hex)
s_bytes = bytes.fromhex(s_hex)
f_bytes = bytes.fromhex(f_hex)
flag_bytes = bytes.fromhex(flag_hex_actual)

print(f"Hospital length: {len(h_bytes)} bytes")
print(f"Subway length: {len(s_bytes)} bytes")
print(f"Financial length: {len(f_bytes)} bytes")
print(f"Flag length: {len(flag_bytes)} bytes")
print()

# Now try XOR operations on the bytes
def xor_bytes(b1, b2):
    """XOR two byte arrays of potentially different lengths"""
    max_len = max(len(b1), len(b2))
    # Pad shorter array
    b1_padded = b1 + b'\x00' * (max_len - len(b1))
    b2_padded = b2 + b'\x00' * (max_len - len(b2))
    return bytes(a ^ b for a, b in zip(b1_padded, b2_padded))

# Try XOR combinations
first_wound = xor_bytes(h_bytes, s_bytes)
second_wound = xor_bytes(h_bytes, f_bytes)

print("First wound (H⊕S):")
print(first_wound.hex()[:100] + "...")
print()

print("Second wound (H⊕F):")
print(second_wound.hex()[:100] + "...")
print()

# Try to decrypt flag with different keys
keys = [
    ("H⊕S⊕F", xor_bytes(xor_bytes(h_bytes, s_bytes), f_bytes)),
    ("H⊕S", first_wound),
    ("H⊕F", second_wound),
    ("S⊕F", xor_bytes(s_bytes, f_bytes)),
]

print("=== Decryption attempts ===\n")
for name, key in keys:
    result = xor_bytes(flag_bytes, key)
    try:
        decoded = result.decode('ascii')
        if all(32 <= ord(c) < 127 for c in decoded):
            print(f"SUCCESS with {name}!")
            print(f"Decrypted: {decoded}")
            print(f"Flag: ctf{{{decoded}}}kernel")
            print()
            break
    except:
        pass
    
    try:
        decoded = result.decode('ascii', errors='ignore')
        printable = ''.join(c if 32 <= ord(c) < 127 else '.' for c in decoded)
        if len([c for c in printable if c != '.']) > len(printable) * 0.5:
            print(f"{name}: {printable[:100]}")
    except:
        pass

print()
